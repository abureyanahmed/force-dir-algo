<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FR Graph â€“ Text Input</title>

<style>
  body {
    font-family: sans-serif;
    background: #f5f5f5;
    margin: 0;
    padding: 10px;
  }

  textarea {
    width: 100%;
    height: 160px;
    margin-bottom: 10px;
    font-family: monospace;
  }

  input, button {
    margin-right: 5px;
    margin-bottom: 5px;
  }

  canvas {
    background: white;
    border: 1px solid #ccc;
    display: block;
  }
</style>
</head>

<body>

<div id="controls">
  <strong>Bounding region</strong><br>
  x: <input type="number" id="rx" value="50">
  y: <input type="number" id="ry" value="50">
  w: <input type="number" id="rw" value="700">
  h: <input type="number" id="rh" value="500">
  <button id="applyRegion">Apply</button>

  <br><br>

  <strong>Graph input</strong><br>
  <textarea id="graphInput" placeholder=
"nodeA 100 100
nodeB 200 150
nodeC 300 120
nodeA nodeB
nodeB nodeC"></textarea>

  <button id="loadGraph">Load graph</button>

  <br><br>

  Period (ms):
  <input type="number" id="periodInput" value="16" min="1">
  Cooling:
  <input type="number" id="coolingInput" value="0.95" min="0" max="1" step="0.01">

  <br><br>
  <button id="startBtn">Start</button>
  <button id="stopBtn">Stop</button>
</div>

<canvas id="graph" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("graph");
const ctx = canvas.getContext("2d");

let nodes = [];
let links = [];
let nodeIndex = new Map();

let region = { x: 50, y: 50, w: 700, h: 500 };

let intervalId = null;
let period = 16;
let cooling = 0.95;
let temperature = 80;
let k = 50;

// ----------------- Helpers -----------------

function clampToRegion(v) {
  v.x = Math.min(region.x + region.w, Math.max(region.x, v.x));
  v.y = Math.min(region.y + region.h, Math.max(region.y, v.y));
}

// ----------------- Forces -----------------

function repulsiveForce(d) {
  return (k * k) / d;
}

function attractiveForce(d) {
  return (d * d) / k;
}

// ----------------- Simulation -----------------

function step() {
  for (let i = 0; i < nodes.length; i++) {
    const v = nodes[i];
    let fx = 0, fy = 0;

    for (let j = 0; j < nodes.length; j++) {
      if (i === j) continue;
      const u = nodes[j];
      let dx = v.x - u.x;
      let dy = v.y - u.y;
      let d = Math.hypot(dx, dy) || 0.01;
      const f = repulsiveForce(d);
      fx += (dx / d) * f;
      fy += (dy / d) * f;
    }

    for (const e of links) {
      let u = null;
      if (e.source === i) u = nodes[e.target];
      else if (e.target === i) u = nodes[e.source];
      else continue;

      let dx = v.x - u.x;
      let dy = v.y - u.y;
      let d = Math.hypot(dx, dy) || 0.01;
      const f = attractiveForce(d);
      fx -= (dx / d) * f;
      fy -= (dy / d) * f;
    }

    const disp = Math.hypot(fx, fy) || 0.01;
    v.x += (fx / disp) * Math.min(disp, temperature);
    v.y += (fy / disp) * Math.min(disp, temperature);

    clampToRegion(v);
  }

  temperature *= cooling;
}

// ----------------- Drawing -----------------

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // region
  ctx.strokeStyle = "#888";
  ctx.strokeRect(region.x, region.y, region.w, region.h);

  // edges
  ctx.strokeStyle = "#aaa";
  ctx.beginPath();
  for (const e of links) {
    const s = nodes[e.source];
    const t = nodes[e.target];
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(t.x, t.y);
  }
  ctx.stroke();

  // nodes
  ctx.fillStyle = "#4682b4";
  ctx.font = "12px sans-serif";
  for (const v of nodes) {
    ctx.beginPath();
    ctx.arc(v.x, v.y, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillText(v.id, v.x + 6, v.y - 6);
  }
}

// ----------------- Parsing -----------------

function loadGraphFromText(text) {
  nodes = [];
  links = [];
  nodeIndex.clear();

  const lines = text.split("\n").map(l => l.trim()).filter(l => l);
  let index = 0;

  // first pass: nodes
  for (const line of lines) {
    const parts = line.split(/\s+/);
    if (parts.length === 3) {
      const [id, x, y] = parts;
      const v = { id, x: +x, y: +y };
      clampToRegion(v);
      nodeIndex.set(id, index++);
      nodes.push(v);
    }
  }

  // second pass: edges
  for (const line of lines) {
    const parts = line.split(/\s+/);
    if (parts.length === 2) {
      const [a, b] = parts;
      if (nodeIndex.has(a) && nodeIndex.has(b)) {
        links.push({
          source: nodeIndex.get(a),
          target: nodeIndex.get(b)
        });
      }
    }
  }

  k = Math.sqrt((region.w * region.h) / Math.max(1, nodes.length));
  temperature = Math.max(region.w, region.h) / 10;
  draw();
}

// ----------------- UI -----------------

applyRegion.onclick = () => {
  region.x = +rx.value;
  region.y = +ry.value;
  region.w = +rw.value;
  region.h = +rh.value;
  draw();
};

loadGraph.onclick = () => {
  loadGraphFromText(graphInput.value);
};

periodInput.onchange = e => {
  period = Math.max(1, +e.target.value);
  if (intervalId) startAnimation();
};

coolingInput.onchange = e => {
  cooling = Math.min(1, Math.max(0, +e.target.value));
};

function startAnimation() {
  stopAnimation();
  intervalId = setInterval(() => {
    step();
    draw();
  }, period);
}

function stopAnimation() {
  if (intervalId !== null) {
    clearInterval(intervalId);
    intervalId = null;
  }
}

startBtn.onclick = startAnimation;
stopBtn.onclick = stopAnimation;

draw();
</script>

</body>
</html>
