<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Force-Directed Graph</title>
  <style>
    body {
      margin: 0;
      background: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      background: white;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>

<canvas id="graph" width="800" height="600"></canvas>

<script>
const nodes = [
  { id: 0, x: Math.random() * 800, y: Math.random() * 600, vx: 0, vy: 0 },
  { id: 1, x: Math.random() * 800, y: Math.random() * 600, vx: 0, vy: 0 },
  { id: 2, x: Math.random() * 800, y: Math.random() * 600, vx: 0, vy: 0 }
];

const links = [
  { source: 0, target: 1 },
  { source: 1, target: 2 }
];

const width = 800;
const height = 600;
const area = width * height;
const k = Math.sqrt(area / nodes.length);

let temperature = width / 10;
const cooling = 0.95;

function repulsiveForce(d) {
  return (k * k) / d;
}

function attractiveForce(d) {
  return (d * d) / k;
}

function step() {
  // Reset velocities
  for (const v of nodes) {
    v.vx = 0;
    v.vy = 0;
  }

  // Repulsion
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const v = nodes[i];
      const u = nodes[j];

      let dx = v.x - u.x;
      let dy = v.y - u.y;
      let dist = Math.hypot(dx, dy) || 0.01;

      const force = repulsiveForce(dist);
      dx /= dist;
      dy /= dist;

      v.vx += dx * force;
      v.vy += dy * force;
      u.vx -= dx * force;
      u.vy -= dy * force;
    }
  }

  // Attraction
  for (const e of links) {
    const v = nodes[e.source];
    const u = nodes[e.target];

    let dx = v.x - u.x;
    let dy = v.y - u.y;
    let dist = Math.hypot(dx, dy) || 0.01;

    const force = attractiveForce(dist);
    dx /= dist;
    dy /= dist;

    v.vx -= dx * force;
    v.vy -= dy * force;
    u.vx += dx * force;
    u.vy += dy * force;
  }

  // Move nodes
  for (const v of nodes) {
    const disp = Math.hypot(v.vx, v.vy) || 0.01;
    v.x += (v.vx / disp) * Math.min(disp, temperature);
    v.y += (v.vy / disp) * Math.min(disp, temperature);

    v.x = Math.min(width, Math.max(0, v.x));
    v.y = Math.min(height, Math.max(0, v.y));
  }

  temperature *= cooling;
}

const canvas = document.getElementById("graph");
const ctx = canvas.getContext("2d");

function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw links
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (const e of links) {
    const s = nodes[e.source];
    const t = nodes[e.target];
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(t.x, t.y);
  }
  ctx.stroke();

  // Draw nodes
  ctx.fillStyle = "#4682b4";
  for (const v of nodes) {
    ctx.beginPath();
    ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function animate() {
  step();
  drawCanvas();
  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
